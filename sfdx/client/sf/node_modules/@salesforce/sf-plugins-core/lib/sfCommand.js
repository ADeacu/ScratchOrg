"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SfCommand = void 0;
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const chalk_1 = require("chalk");
const ux_1 = require("./ux");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/sf-plugins-core', 'messages');
/**
 * A base command that provides convenient access to CLI help
 * output formatting. Extend this command and set specific properties
 * to add help sections to the command's help output.
 *
 * @extends @oclif/core/command
 * @see https://github.com/oclif/core/blob/main/src/command.ts
 */
class SfCommand extends core_1.Command {
    constructor(argv, config) {
        super(argv, config);
        this.warnings = [];
        const outputEnabled = !this.jsonEnabled();
        this.spinner = new ux_1.Spinner(outputEnabled);
        this.progress = new ux_1.Progress(outputEnabled && core_2.envVars.getBoolean(core_2.EnvironmentVariable.SF_USE_PROGRESS_BAR, true));
        this.ux = new ux_1.Ux(outputEnabled);
        this.prompter = new ux_1.Prompter();
        this.lifecycle = core_2.Lifecycle.getInstance();
    }
    get statics() {
        return this.constructor;
    }
    /**
     * Log warning to users. If --json is enabled, then the warning
     * will be added to the json output under the warnings property.
     */
    warn(input) {
        const colorizedArgs = [];
        this.warnings.push(input);
        const message = typeof input === 'string' ? input : input.message;
        colorizedArgs.push(`${chalk_1.default.bold.yellow(messages.getMessage('warning.prefix'))} ${message}`);
        colorizedArgs.push(...this.formatActions(typeof input === 'string' ? [] : input.actions || [], { actionColor: chalk_1.default.reset }));
        this.log(colorizedArgs.join(os.EOL));
        return input;
    }
    /**
     * Log info message to users.
     */
    info(input) {
        const colorizedArgs = [];
        const message = typeof input === 'string' ? input : input.message;
        colorizedArgs.push(`${chalk_1.default.bold(messages.getMessage('info.prefix'))} ${message}`);
        colorizedArgs.push(...this.formatActions(typeof input === 'string' ? [] : input.actions || [], { actionColor: chalk_1.default.reset }));
        this.log(colorizedArgs.join(os.EOL));
    }
    /**
     * Warn user about sensitive information (access tokens, etc...) before
     * logging to the console.
     */
    logSensitive(msg) {
        this.warn(messages.getMessage('warning.security'));
        this.log(msg);
    }
    /**
     * Display a table on the console. Will automatically be suppressed when --json flag is present.
     */
    table(data, columns, options) {
        this.ux.table(data, columns, options);
    }
    /**
     * Log a stylized url to the console. Will automatically be suppressed when --json flag is present.
     */
    url(text, uri, params = {}) {
        this.ux.url(text, uri, params);
    }
    /**
     * Log stylized JSON to the console. Will automatically be suppressed when --json flag is present.
     */
    styledJSON(obj) {
        this.ux.styledJSON(obj);
    }
    /**
     * Log stylized object to the console. Will automatically be suppressed when --json flag is present.
     */
    styledObject(obj) {
        this.ux.styledObject(obj);
    }
    /**
     * Log stylized header to the console. Will automatically be suppressed when --json flag is present.
     */
    styledHeader(text) {
        this.ux.styledHeader(text);
    }
    /**
     * Prompt user for information. See https://www.npmjs.com/package/inquirer for more.
     *
     * This will NOT be automatically suppressed when the --json flag is present since we assume
     * that any command that prompts the user for required information will not also support the --json flag.
     *
     * If you need to conditionally suppress prompts to support json output, then do the following:
     *
     * @example
     * if (!this.jsonEnabled()) {
     *   await this.prompt();
     * }
     */
    async prompt(questions, initialAnswers) {
        return this.prompter.prompt(questions, initialAnswers);
    }
    /**
     * Prompt user for information with a timeout (in milliseconds). See https://www.npmjs.com/package/inquirer for more.
     */
    async timedPrompt(questions, ms = 10000, initialAnswers) {
        return this.prompter.timedPrompt(questions, 10000, initialAnswers);
    }
    async _run() {
        if (this.statics.requiresProject) {
            this.project = await this.assignProject();
        }
        this.lifecycle.onWarning(async (warning) => {
            this.warn(warning);
        });
        return super._run();
    }
    /**
     * Wrap the command result into the standardized JSON structure.
     */
    toSuccessJson(result) {
        var _a;
        return {
            status: (_a = process.exitCode) !== null && _a !== void 0 ? _a : 0,
            result,
            warnings: this.warnings,
        };
    }
    /**
     * Wrap the command error into the standardized JSON structure.
     */
    toErrorJson(error) {
        var _a;
        return {
            status: (_a = process.exitCode) !== null && _a !== void 0 ? _a : 1,
            stack: error.stack,
            name: error.name,
            message: error.message,
            warnings: this.warnings,
        };
    }
    async assignProject() {
        try {
            return await core_2.SfProject.resolve();
        }
        catch (err) {
            if (err instanceof Error && err.name === 'InvalidProjectWorkspaceError') {
                throw messages.createError('errors.RequiresProject');
            }
            throw err;
        }
    }
    async catch(error) {
        var _a, _b;
        process.exitCode = (_b = (_a = process.exitCode) !== null && _a !== void 0 ? _a : error.exitCode) !== null && _b !== void 0 ? _b : 1;
        this.log(this.formatError(error));
        if (this.jsonEnabled()) {
            core_1.CliUx.ux.styledJSON(this.toErrorJson(error));
        }
        return error;
    }
    /**
     * Format errors and actions for human consumption. Adds 'Error:',
     * When there are actions, we add 'Try this:' in blue
     * followed by each action in red on its own line.
     * If Error.code is present it is output last in parentheses
     *
     * @returns {string} Returns decorated messages.
     */
    formatError(error) {
        const colorizedArgs = [];
        colorizedArgs.push(`${chalk_1.default.bold.red(messages.getMessage('error.prefix'))} ${error.message}`);
        colorizedArgs.push(...this.formatActions(error.actions || []));
        if (error.stack && core_2.envVars.getString(SfCommand.SF_ENV) === core_2.Mode.DEVELOPMENT) {
            colorizedArgs.push(chalk_1.default.red(`\n*** Internal Diagnostic ***\n\n${error.stack}\n******\n`));
        }
        if (error.code) {
            colorizedArgs.push(chalk_1.default.bold(`\n(${error.code})`));
        }
        return colorizedArgs.join('\n');
    }
    /**
     * Utility function to format actions lines
     *
     * @param actions
     * @param options
     * @private
     */
    formatActions(actions, options = { actionColor: chalk_1.default.red }) {
        const colorizedArgs = [];
        // Format any actions.
        if (actions === null || actions === void 0 ? void 0 : actions.length) {
            colorizedArgs.push(`\n${chalk_1.default.blue.bold(messages.getMessage('actions.tryThis'))}\n`);
            actions.forEach((action) => {
                colorizedArgs.push(`${options.actionColor(action)}`);
            });
        }
        return colorizedArgs;
    }
}
exports.SfCommand = SfCommand;
SfCommand.SF_ENV = 'SF_ENV';
SfCommand.enableJsonFlag = true;
SfCommand.tableFlags = core_1.CliUx.ux.table.flags;
//# sourceMappingURL=sfCommand.js.map
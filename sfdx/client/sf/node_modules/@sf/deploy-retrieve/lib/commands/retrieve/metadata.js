"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const ts_types_1 = require("@salesforce/ts-types");
const output_1 = require("../../utils/output");
const project_1 = require("../../utils/project");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'retrieve.metadata');
const mdTrasferMessages = core_1.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'metadata.transfer');
class RetrieveMetadata extends sf_plugins_core_1.SfCommand {
    async run() {
        const flags = (await this.parse(RetrieveMetadata)).flags;
        this.spinner.start(messages.getMessage('spinner.start'));
        const componentSet = await source_deploy_retrieve_1.ComponentSetBuilder.build({
            apiversion: flags['api-version'],
            sourcepath: flags['source-dir'],
            packagenames: flags['package-name'],
            manifest: flags.manifest && {
                manifestPath: flags.manifest,
                directoryPaths: await (0, project_1.getPackageDirs)(),
            },
            metadata: flags.metadata && {
                metadataEntries: flags.metadata,
                directoryPaths: await (0, project_1.getPackageDirs)(),
            },
        });
        this.spinner.status = messages.getMessage('spinner.sending', [
            componentSet.sourceApiVersion || componentSet.apiVersion,
        ]);
        const retrieve = await componentSet.retrieve({
            usernameOrConnection: flags['target-org'].getUsername(),
            merge: true,
            output: this.project.getDefaultPackage().fullPath,
            packageOptions: flags['package-name'],
        });
        this.spinner.status = messages.getMessage('spinner.polling');
        retrieve.onUpdate((data) => {
            this.spinner.status = mdTrasferMessages.getMessage(data.status);
        });
        // any thing else should stop the progress bar
        retrieve.onFinish((data) => this.spinner.stop(mdTrasferMessages.getMessage(data.response.status)));
        retrieve.onCancel((data) => this.spinner.stop(mdTrasferMessages.getMessage(data.status)));
        retrieve.onError((error) => {
            this.spinner.stop(error.name);
            throw error;
        });
        await retrieve.start();
        const result = await retrieve.pollStatus(500, flags.wait.seconds);
        this.spinner.stop();
        const fileResponses = (result === null || result === void 0 ? void 0 : result.getFileResponses()) || [];
        if (!this.jsonEnabled()) {
            await this.displayResults(result, flags['package-name']);
        }
        return fileResponses;
    }
    async displayResults(result, packageNames = []) {
        if (result.response.status === 'Succeeded') {
            (0, output_1.displaySuccesses)(result);
            (0, output_1.displayPackages)(result, await this.getPackages(result, packageNames));
        }
        else {
            throw new core_1.SfError((0, ts_types_1.getString)(result.response, 'errorMessage', result.response.status), (0, ts_types_1.getString)(result.response, 'errorStatusCode', 'unknown'));
        }
    }
    async getPackages(result, packageNames = []) {
        const packages = [];
        const projectPath = await core_1.SfProject.resolveProjectPath();
        packageNames.forEach((name) => {
            const packagePath = path.join(projectPath, name);
            packages.push({ name, path: packagePath, fullPath: path.resolve(packagePath) });
        });
        return packages;
    }
}
exports.default = RetrieveMetadata;
RetrieveMetadata.summary = messages.getMessage('summary');
RetrieveMetadata.description = messages.getMessage('description');
RetrieveMetadata.examples = messages.getMessages('examples');
RetrieveMetadata.requiresProject = true;
RetrieveMetadata.flags = {
    'api-version': sf_plugins_core_1.Flags.orgApiVersion({
        char: 'a',
        summary: messages.getMessage('flags.api-version.summary'),
        description: messages.getMessage('flags.api-version.description'),
    }),
    manifest: sf_plugins_core_1.Flags.file({
        char: 'x',
        summary: messages.getMessage('flags.manifest.summary'),
        description: messages.getMessage('flags.manifest.description'),
        exclusive: ['metadata', 'source-dir'],
        exists: true,
    }),
    metadata: sf_plugins_core_1.Flags.string({
        char: 'm',
        summary: messages.getMessage('flags.metadata.summary'),
        multiple: true,
        exclusive: ['manifest', 'source-dir'],
    }),
    'package-name': sf_plugins_core_1.Flags.string({
        char: 'n',
        summary: messages.getMessage('flags.package-name.summary'),
        multiple: true,
    }),
    'source-dir': sf_plugins_core_1.Flags.string({
        char: 'd',
        summary: messages.getMessage('flags.source-dir.summary'),
        description: messages.getMessage('flags.source-dir.description'),
        multiple: true,
        exclusive: ['manifest', 'metadata'],
    }),
    'target-org': sf_plugins_core_1.Flags.requiredOrg({
        char: 'o',
        summary: messages.getMessage('flags.target-org.summary'),
        description: messages.getMessage('flags.target-org.description'),
    }),
    wait: sf_plugins_core_1.Flags.duration({
        char: 'w',
        defaultValue: 33,
        unit: 'minutes',
        summary: messages.getMessage('flags.wait.summary'),
        description: messages.getMessage('flags.wait.description'),
    }),
};
RetrieveMetadata.configurationVariablesSection = (0, sf_plugins_core_1.toHelpSection)('CONFIGURATION VARIABLES', core_1.OrgConfigProperties.TARGET_ORG, core_1.SfdxPropertyKeys.API_VERSION);
RetrieveMetadata.envVariablesSection = (0, sf_plugins_core_1.toHelpSection)('ENVIRONMENT VARIABLES', core_1.EnvironmentVariable.SF_TARGET_ORG, core_1.EnvironmentVariable.SFDX_DEFAULTUSERNAME, core_1.EnvironmentVariable.SFDX_USE_PROGRESS_BAR);
//# sourceMappingURL=metadata.js.map
"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEPLOY_OPTIONS_FILE = void 0;
const os_1 = require("os");
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const fs_extra_1 = require("fs-extra");
const kit_1 = require("@salesforce/kit");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const shelljs_1 = require("shelljs");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'deploy');
exports.DEPLOY_OPTIONS_FILE = 'deploy-options.json';
class Deploy extends sf_plugins_core_1.SfCommand {
    async run() {
        var _a;
        process.setMaxListeners(new kit_1.Env().getNumber('SF_MAX_EVENT_LISTENERS') || 1000);
        const { flags } = await this.parse(Deploy);
        flags.interactive = await this.isInteractive(flags.interactive);
        const options = await this.readOptions();
        this.log('Analyzing project');
        if (!flags.interactive) {
            this.log(`Using options found in ${exports.DEPLOY_OPTIONS_FILE}`);
        }
        const hookResults = await sf_plugins_core_1.SfHook.run(this.config, 'sf:deploy', options);
        let deployers = hookResults.successes.flatMap((s) => s.result);
        if (deployers.length === 0) {
            this.log('Found nothing in the project to deploy');
        }
        else {
            if (flags.interactive) {
                deployers = await this.selectDeployers(deployers);
            }
            else {
                deployers = deployers.filter((d) => !!options[d.getName()]);
            }
            if (deployers.length === 0) {
                this.log('Nothing was selected to deploy.');
            }
            const deployOptions = {};
            for (const deployer of deployers) {
                const opts = (_a = options[deployer.getName()]) !== null && _a !== void 0 ? _a : {};
                deployOptions[deployer.getName()] = await deployer.setup(flags, opts);
            }
            if (flags.interactive && (await this.askToSave())) {
                await (0, fs_extra_1.writeJson)(exports.DEPLOY_OPTIONS_FILE, deployOptions);
                this.log();
                this.log(`Your deploy options have been saved to ${exports.DEPLOY_OPTIONS_FILE}`);
                if (await this.shouldCommit()) {
                    await this.commit();
                    this.log(`We added ${exports.DEPLOY_OPTIONS_FILE} to the .gitignore for you.`);
                }
            }
            for (const deployer of deployers) {
                await deployer.deploy();
            }
        }
    }
    /**
     * If the deploy file exists, we do not want the command to be interactive. But if the file
     * does not exist then we want to force the command to be interactive.
     */
    async isInteractive(interactive) {
        if (interactive)
            return true;
        const deployFileExists = await (0, fs_extra_1.pathExists)(exports.DEPLOY_OPTIONS_FILE);
        return deployFileExists ? false : true;
    }
    async readOptions() {
        if (await (0, fs_extra_1.pathExists)(exports.DEPLOY_OPTIONS_FILE)) {
            return (0, kit_1.parseJsonMap)(await (0, fs_extra_1.readFile)(exports.DEPLOY_OPTIONS_FILE, 'utf8'));
        }
        else {
            return {};
        }
    }
    async commit() {
        const gitignore = await (0, fs_extra_1.readFile)('.gitignore', 'utf-8');
        if (!gitignore.includes(exports.DEPLOY_OPTIONS_FILE)) {
            const addition = `${os_1.EOL}${os_1.EOL}# Deploy Options${os_1.EOL}${exports.DEPLOY_OPTIONS_FILE}${os_1.EOL}`;
            await (0, fs_extra_1.writeFile)('.gitignore', `${gitignore}${addition}`);
        }
        (0, shelljs_1.exec)('git add .gitignore', { silent: true });
        (0, shelljs_1.exec)(`git commit -am "Add ${exports.DEPLOY_OPTIONS_FILE} to .gitignore"`, { silent: true });
    }
    async shouldCommit() {
        return (await (0, fs_extra_1.pathExists)('.git')) && (await (0, fs_extra_1.pathExists)('functions'));
    }
    async askToSave() {
        const prompter = new sf_plugins_core_1.Prompter();
        const { save } = await prompter.prompt({
            name: 'save',
            message: 'Would you like to save these deploy options for future runs?',
            type: 'confirm',
        });
        return save;
    }
    async selectDeployers(deployers) {
        const deployables = deployers.reduce((x, y) => x.concat(y.deployables), []);
        const columns = { name: 'APP OR PACKAGE', type: 'TYPE', path: 'PATH' };
        const options = deployables.map((deployable) => ({
            name: deployable.getName(),
            type: deployable.getType(),
            path: deployable.getPath(),
            value: deployable,
        }));
        const prompter = new sf_plugins_core_1.Prompter();
        const responses = await prompter.prompt([
            {
                name: 'deployables',
                message: 'Select apps and packages to deploy:',
                type: 'checkbox',
                choices: (0, sf_plugins_core_1.generateTableChoices)(columns, options),
            },
        ]);
        const chosenDeployers = new Map();
        for (const deployable of responses.deployables) {
            const parent = deployable.getParent();
            if (chosenDeployers.has(parent)) {
                const existing = chosenDeployers.get(parent) || [];
                chosenDeployers.set(parent, [...existing, deployable]);
            }
            else {
                chosenDeployers.set(parent, [deployable]);
            }
        }
        const final = [];
        for (const [parent, children] of Array.from(chosenDeployers.entries())) {
            parent.selectDeployables(children);
            final.push(parent);
        }
        return final;
    }
}
exports.default = Deploy;
Deploy.summary = messages.getMessage('summary');
Deploy.description = messages.getMessage('description');
Deploy.examples = messages.getMessages('examples');
Deploy.enableJsonFlag = false;
Deploy.flags = {
    interactive: core_1.Flags.boolean({
        summary: messages.getMessage('flags.interactive.summary'),
    }),
};
//# sourceMappingURL=deploy.js.map
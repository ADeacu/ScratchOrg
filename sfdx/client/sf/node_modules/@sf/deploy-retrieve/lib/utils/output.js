"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVersionMessage = exports.displayDeletes = exports.displayFailures = exports.displayTestResults = exports.displayPackages = exports.displaySuccesses = exports.displayDeployResults = exports.toArray = exports.sortTestResults = exports.sortFileResponses = exports.asRelativePaths = void 0;
const os = require("os");
const path = require("path");
const core_1 = require("@oclif/core");
const chalk_1 = require("chalk");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const types_1 = require("./types");
function info(message) {
    return (0, chalk_1.blue)((0, chalk_1.bold)(message));
}
function error(message) {
    return (0, chalk_1.red)((0, chalk_1.bold)(message));
}
function success(message) {
    return (0, chalk_1.green)((0, chalk_1.bold)(message));
}
function table(responses, columns, options) {
    // Interfaces cannot be casted to Record<string, unknown> so we have to cast to unknown first
    // See https://github.com/microsoft/TypeScript/issues/15300
    core_1.CliUx.ux.table(responses, columns, options !== null && options !== void 0 ? options : {});
}
const check = (0, chalk_1.green)('✓');
function asRelativePaths(fileResponses) {
    fileResponses.forEach((file) => {
        if (file.filePath) {
            file.filePath = path.relative(process.cwd(), file.filePath);
        }
    });
    return fileResponses;
}
exports.asRelativePaths = asRelativePaths;
/**
 * Sorts file responds by type, then by filePath, then by fullName
 */
function sortFileResponses(fileResponses) {
    return fileResponses.sort((i, j) => {
        if (i.type === j.type && i.filePath && j.filePath) {
            if (i.filePath === j.filePath) {
                return i.fullName > j.fullName ? 1 : -1;
            }
            return (i === null || i === void 0 ? void 0 : i.filePath) > (j === null || j === void 0 ? void 0 : j.filePath) ? 1 : -1;
        }
        return i.type > j.type ? 1 : -1;
    });
}
exports.sortFileResponses = sortFileResponses;
function sortTestResults(results = []) {
    return results.sort((a, b) => {
        if (a.methodName === b.methodName) {
            return a.name.localeCompare(b.name);
        }
        return a.methodName.localeCompare(b.methodName);
    });
}
exports.sortTestResults = sortTestResults;
function toArray(entryOrArray) {
    if (entryOrArray) {
        return Array.isArray(entryOrArray) ? entryOrArray : [entryOrArray];
    }
    return [];
}
exports.toArray = toArray;
function displayDeployResults(result, testLevel, verbose) {
    displaySuccesses(result);
    displayFailures(result);
    displayDeletes(result);
    displayTestResults(result, testLevel, verbose);
}
exports.displayDeployResults = displayDeployResults;
function displaySuccesses(result) {
    var _a;
    const fileResponses = asRelativePaths((_a = result.getFileResponses()) !== null && _a !== void 0 ? _a : []);
    const successes = sortFileResponses(fileResponses.filter((f) => f.state !== 'Failed'));
    if (!successes.length)
        return;
    const columns = {
        state: { header: 'State' },
        fullName: { header: 'Name' },
        type: { header: 'Type' },
        filePath: { header: 'Path' },
    };
    const title = result instanceof source_deploy_retrieve_1.DeployResult ? 'Deployed Source' : 'Retrieved Source';
    const options = { title: info(title) };
    core_1.CliUx.ux.log();
    table(successes, columns, options);
}
exports.displaySuccesses = displaySuccesses;
function displayPackages(result, packages) {
    if (packages === null || packages === void 0 ? void 0 : packages.length) {
        const columns = {
            name: { header: 'Package Name' },
            fullPath: { header: 'Converted Location' },
        };
        const title = 'Retrieved Packages';
        const options = { title: info(title) };
        core_1.CliUx.ux.log();
        table(packages, columns, options);
    }
}
exports.displayPackages = displayPackages;
function displayTestResults(result, testLevel, verbose = false) {
    var _a, _b, _c, _d;
    if (testLevel === types_1.TestLevel.NoTestRun) {
        core_1.CliUx.ux.log();
        return;
    }
    displayVerboseTestFailures(result);
    if (verbose) {
        displayVerboseTestSuccesses(result);
        displayVerboseTestCoverage(result);
    }
    core_1.CliUx.ux.log();
    core_1.CliUx.ux.log(info('Test Results Summary'));
    const passing = (_a = result.response.numberTestsCompleted) !== null && _a !== void 0 ? _a : 0;
    const failing = (_b = result.response.numberTestErrors) !== null && _b !== void 0 ? _b : 0;
    const total = (_c = result.response.numberTestsTotal) !== null && _c !== void 0 ? _c : 0;
    const time = (_d = result.response.details.runTestResult.totalTime) !== null && _d !== void 0 ? _d : 0;
    core_1.CliUx.ux.log(`Passing: ${passing}`);
    core_1.CliUx.ux.log(`Failing: ${failing}`);
    core_1.CliUx.ux.log(`Total: ${total}`);
    if (time)
        core_1.CliUx.ux.log(`Time: ${time}`);
}
exports.displayTestResults = displayTestResults;
function displayVerboseTestFailures(result) {
    var _a, _b, _c;
    if (!result.response.numberTestErrors)
        return;
    const failures = toArray((_b = (_a = result.response.details) === null || _a === void 0 ? void 0 : _a.runTestResult) === null || _b === void 0 ? void 0 : _b.failures);
    const failureCount = (_c = result.response.details.runTestResult) === null || _c === void 0 ? void 0 : _c.numFailures;
    const testFailures = sortTestResults(failures);
    core_1.CliUx.ux.log();
    core_1.CliUx.ux.log(error(`Test Failures [${failureCount}]`));
    for (const test of testFailures) {
        const testName = (0, chalk_1.underline)(`${test.name}.${test.methodName}`);
        const stackTrace = test.stackTrace.replace(/\n/g, `${os.EOL}    `);
        core_1.CliUx.ux.log(`• ${testName}`);
        core_1.CliUx.ux.log(`  ${(0, chalk_1.dim)('message')}: ${test.message}`);
        core_1.CliUx.ux.log(`  ${(0, chalk_1.dim)('stacktrace')}: ${os.EOL}    ${stackTrace}`);
        core_1.CliUx.ux.log();
    }
}
function displayVerboseTestSuccesses(result) {
    var _a, _b;
    const successes = toArray((_b = (_a = result.response.details) === null || _a === void 0 ? void 0 : _a.runTestResult) === null || _b === void 0 ? void 0 : _b.successes);
    if (successes.length > 0) {
        const testSuccesses = sortTestResults(successes);
        core_1.CliUx.ux.log();
        core_1.CliUx.ux.log(success(`Test Success [${successes.length}]`));
        for (const test of testSuccesses) {
            const testName = (0, chalk_1.underline)(`${test.name}.${test.methodName}`);
            core_1.CliUx.ux.log(`${check} ${testName}`);
        }
    }
}
function displayVerboseTestCoverage(result) {
    var _a;
    const codeCoverage = toArray((_a = result.response.details.runTestResult) === null || _a === void 0 ? void 0 : _a.codeCoverage);
    if (codeCoverage.length) {
        const coverage = codeCoverage.sort((a, b) => {
            return a.name.toUpperCase() > b.name.toUpperCase() ? 1 : -1;
        });
        core_1.CliUx.ux.log();
        core_1.CliUx.ux.log(info('Apex Code Coverage'));
        coverage.map((cov) => {
            const numLocationsNum = parseInt(cov.numLocations, 10);
            const numLocationsNotCovered = parseInt(cov.numLocationsNotCovered, 10);
            const color = numLocationsNotCovered > 0 ? chalk_1.red : chalk_1.green;
            let pctCovered = 100;
            const coverageDecimal = parseFloat(((numLocationsNum - numLocationsNotCovered) / numLocationsNum).toFixed(2));
            if (numLocationsNum > 0) {
                pctCovered = coverageDecimal * 100;
            }
            cov.numLocations = color(`${pctCovered}%`);
            if (!cov.locationsNotCovered) {
                cov.lineNotCovered = '';
            }
            const locations = toArray(cov.locationsNotCovered);
            cov.lineNotCovered = locations.map((location) => location.line).join(',');
        });
        table(coverage, {
            name: { header: 'Name' },
            numLocations: { header: '% Covered' },
            lineNotCovered: { header: 'Uncovered Lines' },
        });
    }
}
function displayFailures(result) {
    var _a;
    if (result.response.status === source_deploy_retrieve_1.RequestStatus.Succeeded)
        return;
    const fileResponses = asRelativePaths((_a = result.getFileResponses()) !== null && _a !== void 0 ? _a : []);
    const failures = sortFileResponses(fileResponses.filter((f) => f.state === 'Failed'));
    if (!failures.length)
        return;
    const columns = {
        problemType: { header: 'Type' },
        fullName: { header: 'Name' },
        error: { header: 'Problem' },
    };
    const options = { title: error(`Component Failures [${failures.length}]`) };
    core_1.CliUx.ux.log();
    table(failures, columns, options);
}
exports.displayFailures = displayFailures;
function displayDeletes(result) {
    var _a;
    const fileResponses = asRelativePaths((_a = result.getFileResponses()) !== null && _a !== void 0 ? _a : []);
    const deletions = sortFileResponses(fileResponses.filter((f) => f.state === 'Deleted'));
    if (!deletions.length)
        return;
    const columns = {
        fullName: { header: 'Name' },
        type: { header: 'Type' },
        filePath: { header: 'Path' },
    };
    const options = { title: info('Deleted Source') };
    core_1.CliUx.ux.log();
    table(deletions, columns, options);
}
exports.displayDeletes = displayDeletes;
function getVersionMessage(action, componentSet, api) {
    var _a;
    // commands pass in the.componentSet, which may not exist in some tests or mdapi deploys
    if (!componentSet) {
        return `*** ${action} with ${api} ***`;
    }
    // neither
    if (!componentSet.sourceApiVersion && !componentSet.apiVersion) {
        return `*** ${action} with ${api} ***`;
    }
    // either OR both match (SDR will use either)
    if (!componentSet.sourceApiVersion ||
        !componentSet.apiVersion ||
        componentSet.sourceApiVersion === componentSet.apiVersion) {
        return `*** ${action} with ${api} API v${(_a = componentSet.apiVersion) !== null && _a !== void 0 ? _a : componentSet.sourceApiVersion} ***`;
    }
    // has both but they don't match
    return `*** ${action} v${componentSet.sourceApiVersion} metadata with ${api} API v${componentSet.apiVersion} connection ***`;
}
exports.getVersionMessage = getVersionMessage;
//# sourceMappingURL=output.js.map
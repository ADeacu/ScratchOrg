"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTestResults = exports.testLevelFlag = exports.executeDeploy = exports.resolveRestDeploy = exports.validateTests = void 0;
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const project_1 = require("./project");
const types_1 = require("./types");
function validateTests(testLevel, tests) {
    if (testLevel === types_1.TestLevel.RunSpecifiedTests && (tests !== null && tests !== void 0 ? tests : []).length === 0)
        return false;
    return true;
}
exports.validateTests = validateTests;
function resolveRestDeploy() {
    const restDeployConfig = core_2.ConfigAggregator.getValue(core_2.SfdxPropertyKeys.REST_DEPLOY).value;
    if (restDeployConfig === 'false') {
        return types_1.API.SOAP;
    }
    else if (restDeployConfig === 'true') {
        return types_1.API.REST;
    }
    else {
        return types_1.API.SOAP;
    }
}
exports.resolveRestDeploy = resolveRestDeploy;
async function executeDeploy(opts) {
    const componentSet = await source_deploy_retrieve_1.ComponentSetBuilder.build({
        apiversion: opts['api-version'],
        sourceapiversion: await (0, project_1.getSourceApiVersion)(),
        sourcepath: opts['source-dir'],
        manifest: opts.manifest && {
            manifestPath: opts.manifest,
            directoryPaths: await (0, project_1.getPackageDirs)(),
        },
        metadata: opts.metadata && {
            metadataEntries: opts.metadata,
            directoryPaths: await (0, project_1.getPackageDirs)(),
        },
    });
    const deploy = await componentSet.deploy({
        usernameOrConnection: opts['target-org'],
        apiOptions: {
            checkOnly: opts['dry-run'] || false,
            ignoreWarnings: opts['ignore-warnings'] || false,
            rest: opts.api === types_1.API.REST,
            rollbackOnError: !opts['ignore-errors'] || false,
            runTests: opts.tests || [],
            testLevel: opts['test-level'],
        },
    });
    return { deploy, componentSet };
}
exports.executeDeploy = executeDeploy;
const testLevelFlag = (opts = {}) => {
    return core_1.Flags.build({
        char: 'l',
        parse: (input) => Promise.resolve(input),
        options: Object.values(types_1.TestLevel),
        ...opts,
    })();
};
exports.testLevelFlag = testLevelFlag;
function getTestResults(result) {
    var _a, _b, _c;
    const passing = (_a = result.response.numberTestsCompleted) !== null && _a !== void 0 ? _a : 0;
    const failing = (_b = result.response.numberTestErrors) !== null && _b !== void 0 ? _b : 0;
    const total = (_c = result.response.numberTestsTotal) !== null && _c !== void 0 ? _c : 0;
    const testResults = { passing, failing, total };
    const time = result.response.details.runTestResult.totalTime;
    return time ? { ...testResults, time } : testResults;
}
exports.getTestResults = getTestResults;
//# sourceMappingURL=deploy.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const Stream = require("stream");
const util = require("util");
const color_1 = require("@heroku-cli/color");
const axios_1 = require("axios");
const cli_ux_1 = require("cli-ux");
const EventSource = require("@heroku/eventsource");
const core_1 = require("@salesforce/core");
const core_2 = require("@oclif/core");
const flags_1 = require("../../../lib/flags");
const base_1 = require("../../../lib/base");
const utils_1 = require("../../../lib/utils");
// this splits a stream into lines
function lineTransform() {
    const transform = new Stream.Transform({ objectMode: true, decodeStrings: false });
    let _lastLineData;
    transform._transform = function (chunk, _encoding, next) {
        let data = chunk;
        if (_lastLineData)
            data = _lastLineData + data;
        const lines = data.split('\n');
        _lastLineData = lines.splice(lines.length - 1, 1)[0];
        lines.forEach(this.push.bind(this));
        next();
    };
    transform._flush = function (done) {
        if (_lastLineData)
            this.push(_lastLineData);
        _lastLineData = '';
        done();
    };
    return transform;
}
function eventSourceStream(url, eventSourceOptions, tail) {
    let eventSource;
    const stream = new Stream.Readable({
        read(_size) {
            if (!eventSource) {
                eventSource = new EventSource(url, eventSourceOptions);
                eventSource.addEventListener('error', (error) => {
                    let msg;
                    if (error.status) {
                        msg = [404, 403].includes(error.status)
                            ? 'Log stream timed out. Please try again'
                            : `Logs eventsource failed with ${error.status} ${error.message}`;
                    }
                    else if (error.message) {
                        msg = error.message;
                    }
                    if (msg) {
                        // something bad happened. we probably can't recover, so end the stream and emit an error
                        stream.destroy(new Error(msg));
                    }
                    else if (!tail) {
                        // closed by server for a different reason; out of logs, connection closed without error
                        // Since we are not tailing, send the EOF signal to close the stream
                        stream.push(null);
                    }
                });
                eventSource.addEventListener('message', (event) => {
                    stream.push(event.data);
                });
            }
        },
        destroy(error, callback) {
            if (eventSource) {
                // ensure connection to the server is closed always
                eventSource.close();
            }
            callback(error);
        },
    });
    return stream;
}
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-functions', 'env.log.tail');
class LogTail extends base_1.default {
    async run() {
        var _a;
        const { flags } = await this.parse(LogTail);
        // We support both versions of the flag here for the sake of backward compat
        const targetCompute = (_a = flags['target-compute']) !== null && _a !== void 0 ? _a : flags.environment;
        if (!targetCompute) {
            throw new core_2.Errors.CLIError(`Missing required flag:
        -c, --target-compute TARGET-COMPUTE  ${color_1.default.dim('Environment name.')}
       See more help with --help`);
        }
        if (flags.environment) {
            this.warn(messages.getMessage('flags.environment.deprecation'));
        }
        const appName = await (0, utils_1.resolveAppNameForEnvironment)(targetCompute);
        const response = await this.client.post(`/apps/${appName}/log-sessions`, {
            data: {
                tail: true,
            },
        });
        const logURL = response.data.logplex_url;
        if (logURL) {
            await this.readLogs(logURL, true);
        }
        else {
            this.error("Couldn't retreive logs");
        }
        cli_ux_1.cli.action.stop();
    }
    async simpleStreamingStream(logSessionURL) {
        const response = await (0, axios_1.default)({
            method: 'get',
            url: logSessionURL,
            responseType: 'stream',
        });
        const liner = lineTransform();
        response.data.setEncoding('utf8');
        return response.data.pipe(liner);
    }
    eventSourceStream(logSessionURL, tail) {
        return eventSourceStream(logSessionURL, {}, tail);
    }
    async readLogs(logSessionURL, tail) {
        const u = new URL(logSessionURL);
        const stream = u.searchParams.has('srv')
            ? await this.simpleStreamingStream(logSessionURL)
            : this.eventSourceStream(logSessionURL, tail);
        stream.setEncoding('utf8');
        stream.on('data', (data) => {
            cli_ux_1.cli.log(data);
        });
        const finished = util.promisify(Stream.finished);
        await finished(stream);
    }
}
exports.default = LogTail;
LogTail.summary = messages.getMessage('summary');
LogTail.examples = messages.getMessages('examples');
LogTail.flags = {
    'target-compute': flags_1.FunctionsFlagBuilder.environment({
        description: messages.getMessage('flags.target-compute.summary'),
        exclusive: ['environment'],
    }),
    environment: flags_1.FunctionsFlagBuilder.environment({
        char: 'e',
        exclusive: ['target-compute'],
        hidden: true,
    }),
};

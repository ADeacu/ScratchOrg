"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const core_1 = require("@oclif/core");
const functions_core_1 = require("@heroku/functions-core");
const cli_ux_1 = require("cli-ux");
const color_1 = require("@heroku-cli/color");
const core_2 = require("@salesforce/core");
const get_stdin_1 = require("../../lib/get-stdin");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-functions', 'run.function');
class Invoke extends core_1.Command {
    async run() {
        var _a, _b;
        const { flags } = await this.parse(Invoke);
        const url = (_a = flags['function-url']) !== null && _a !== void 0 ? _a : flags.url;
        if (!url) {
            throw new core_1.Errors.CLIError(`Missing required flag:
       -l, --function-url FUNCTION-URL  ${color_1.default.dim('Function name.')}
       See more help with --help`);
        }
        if (flags.url) {
            this.warn(messages.getMessage('flags.url.deprecation'));
        }
        flags.payload = await this.getPayloadData(flags.payload);
        if (!flags.payload) {
            this.error('no payload provided (provide via stdin or -p)');
        }
        const aggregator = await core_2.ConfigAggregator.create();
        const targetOrg = aggregator.getPropertyValue('target-org');
        if (!flags['connected-org'] && !targetOrg) {
            this.warn('No -o connected org or target-org found, context will be partially initialized');
        }
        const aliasOrUser = flags['connected-org'] || `target-org ${targetOrg}`;
        this.log(`Using ${aliasOrUser} login credential to initialize context`);
        const runFunctionOptions = Object.assign(Object.assign({}, flags), { url, targetusername: (_b = flags['connected-org']) !== null && _b !== void 0 ? _b : targetOrg });
        cli_ux_1.cli.action.start(`${color_1.default.cyanBright('POST')} ${url}`);
        try {
            const response = await (0, functions_core_1.runFunction)(runFunctionOptions);
            cli_ux_1.cli.action.stop(color_1.default.greenBright(response.status.toString()));
            this.writeResponse(response);
        }
        catch (err) {
            const error = err;
            cli_ux_1.cli.debug(error);
            if (error.response) {
                cli_ux_1.cli.action.stop(color_1.default.redBright(`${error.response.status} ${error.response.statusText}`));
                this.debug(error.response);
                this.error(error.response.data);
            }
            else {
                cli_ux_1.cli.action.stop(color_1.default.redBright('Error'));
                this.error(error);
            }
        }
    }
    async getPayloadData(payload) {
        if (payload && payload.startsWith('@')) {
            return fs.readFileSync(payload.slice(1), 'utf8');
        }
        return payload || (0, get_stdin_1.default)();
    }
    writeResponse(response) {
        const contentType = response.headers['content-type'];
        if (contentType.includes('application/json') || contentType.includes('application/cloudevents+json')) {
            cli_ux_1.cli.styledJSON(response.data);
        }
        else {
            this.log(response.data);
        }
    }
}
exports.default = Invoke;
Invoke.summary = messages.getMessage('summary');
Invoke.examples = messages.getMessages('examples');
Invoke.flags = {
    'function-url': core_1.Flags.string({
        exclusive: ['url'],
        char: 'l',
        description: messages.getMessage('flags.function-url.summary'),
    }),
    url: core_1.Flags.string({
        exclusive: ['function-url'],
        char: 'l',
        description: messages.getMessage('flags.function-url.summary'),
        hidden: true,
    }),
    headers: core_1.Flags.string({
        char: 'H',
        description: messages.getMessage('flags.headers.summary'),
        multiple: true,
    }),
    payload: core_1.Flags.string({
        char: 'p',
        description: messages.getMessage('flags.payload.summary'),
    }),
    structured: core_1.Flags.boolean({
        char: 's',
        description: messages.getMessage('flags.structured.summary'),
    }),
    'connected-org': core_1.Flags.string({
        char: 'o',
        description: messages.getMessage('flags.connected-org.summary'),
    }),
};
